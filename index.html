<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Dexsuite Data Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<!-- Plotly -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<!-- Fonts -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<style>
  /* ====== THEME (dark / light) ====== */
  :root{
    --bg: #0b0e10; --panel:#12161a; --card:#0f1317; --ring:#222a32; --muted:#9bb0c2; --fg:#eaf3ff;
    --accent:#0066ff; --accent-2:#68b2ff; --chip:#1b2128; --chip-hover:#222a32; --plot-bg:#0b0e10;
  }
  [data-theme="light"]{
    --bg:#ffffff; --panel:#f6f8fb; --card:#ffffff; --ring:#e3e8ef; --muted:#5b6b7a; --fg:#0d1117;
    --accent:#0066ff; --accent-2:#7dbdff; --chip:#eef3f9; --chip-hover:#e7edf6; --plot-bg:#ffffff;
  }

  *{ box-sizing:border-box; }
  html, body { margin:0; background:var(--bg); color:var(--fg); font-family:Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif }
  /* FIX: let the page scroll naturally; bottom bar is not fixed anymore */
  .app{
    display:grid; grid-template-columns: 300px 1fr;
    grid-template-rows: auto 1fr auto;
    grid-template-areas:
      "sidebar header"
      "sidebar main"
      "controls controls";
    gap:16px;
    min-height:100vh; /* was height:100vh; -> removed */
    height:auto;      /* allow natural page height */
    padding:16px;
  }

  header{
    grid-area:header; display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px; background:var(--panel); border:1px solid var(--ring); border-radius:14px;
  }
  .title{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; }
  .badge{ padding:4px 10px; border-radius:999px; background:linear-gradient(135deg, var(--accent), var(--accent-2)); color:white; font-size:12px; }
  .kpi{ display:flex; gap:18px; align-items:center; color:var(--muted); font-size:13px; }
  .kpi strong{ color:var(--fg); }
  .toggle{
    border:1px solid var(--ring); background:var(--card); color:var(--fg);
    padding:8px 12px; border-radius:10px; cursor:pointer;
  }

  .sidebar{
    grid-area:sidebar; display:flex; flex-direction:column; gap:14px; padding:12px;
    background:var(--panel); border:1px solid var(--ring); border-radius:14px; min-height:0;
  }
  .sidebar h3{ margin:0 0 6px; font-size:12px; color:var(--muted); font-weight:700; letter-spacing:.5px; text-transform:uppercase; }
  .hint{ color:var(--muted); font-size:12px; }
  .btn{
    display:inline-flex; align-items:center; gap:8px; border:1px solid var(--ring); background:var(--card);
    padding:9px 12px; border-radius:10px; color:var(--fg); cursor:pointer; transition:all .15s ease;
  }
  .btn:hover{ transform:translateY(-1px); background:var(--chip-hover) }
  .toolbar input[type=file]{ display:none; }
  .field{
    display:flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--ring);
    background:var(--card); border-radius:10px;
  }
  .field input, .field select{ background:transparent; border:none; color:var(--fg); outline:none; font:inherit; }

  /* Demo chips with include toggle + remove; UI shows renumbered names */
  .chips{ display:flex; flex-direction:column; gap:8px; overflow:auto; padding-right:4px; max-height:220px; }
  .chip{
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    padding:9px 12px; border-radius:10px; background:var(--chip); border:1px solid var(--ring);
    user-select:none; transition:all .15s ease; font-weight:600; color:#cfe3ff;
  }
  [data-theme="light"] .chip{ color:#114; }
  .chip:hover{ background:var(--chip-hover); }
  .chip .left{ display:flex; align-items:center; gap:10px; cursor:pointer; }
  .chip .remove{ cursor:pointer; opacity:.8; }
  .chip .remove:hover{ opacity:1; filter:brightness(1.2); }
  .mini{ font-size:12px; color:var(--muted); }

  .main{ grid-area:main; display:grid; grid-template-columns: 1.2fr 1fr; gap:16px; min-height:0; }
  .cameras{
    background:var(--panel); border:1px solid var(--ring); border-radius:14px; padding:12px; min-height:0;
    display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap:12px; align-content:start;
  }
  .cam-card{
    position:relative; background:var(--card); border:1px solid var(--ring); border-radius:12px; overflow:hidden;
    aspect-ratio: 1 / 1;
  }
  .cam-card canvas{ width:100%; height:100%; display:block; }
  .cam-label{ position:absolute; top:8px; left:8px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:6px; font-size:12px; backdrop-filter: blur(6px); }
  [data-theme="light"] .cam-label{ background:rgba(0,0,0,.45); }

  .plots{ display:grid; grid-template-rows: 220px 220px 1fr; gap:16px; min-height:0; }
  .plot-card{ background:var(--panel); border:1px solid var(--ring); border-radius:14px; overflow:hidden; min-height:0; }
  .plot{ width:100%; height:100%; }

  .controls{
    grid-area:controls; display:flex; gap:12px; align-items:center; padding:12px; background:var(--panel);
    border:1px solid var(--ring); border-radius:14px; flex-wrap:wrap;
  }
  .play{
    padding:10px 16px; border-radius:12px; background:var(--accent); color:white; font-weight:800; border:none; cursor:pointer;
    box-shadow: 0 6px 16px rgba(0,102,255,.35);
  }
  .play:hover{ filter:brightness(1.05) }
  .slider{ flex:1; min-width:200px; }
  input[type=range]{ width:100%; accent-color: var(--accent); }
  .spacer{ flex:1; }
  .tag{ padding:4px 8px; border-radius:8px; background:var(--chip); border:1px solid var(--ring); color:var(--muted); font-size:12px; }

  /* Progress overlay for exports */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); z-index:9999;
  }
  .overlay .box{
    width:min(560px, 92vw); padding:18px; border-radius:12px; background:var(--panel); border:1px solid var(--ring);
  }
  .progress{ height:8px; background:#111; border-radius:6px; overflow:hidden; margin-top:8px; }
  .bar{ height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent-2)); transition:width .2s ease; }
</style>
</head>
<body data-theme="dark">
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div>
      <h3>File</h3>
      <div class="toolbar">
        <label class="btn" for="fileInput">üìÅ Upload HDF5</label>
        <input id="fileInput" type="file" accept=".h5,.hdf5"/>
      </div>
      <div class="hint" id="fileInfo" style="margin-top:8px;">No file loaded.</div>
    </div>

    <div>
      <h3>Demos (UI renumbered)</h3>
      <div id="demoChips" class="chips"></div>
      <div class="hint mini">Click name to view. ‚úì include for export. üóë removes from this session (original file unchanged).</div>
    </div>

    <div>
      <h3>Cameras (select up to 8)</h3>
      <div class="field" style="margin-bottom:6px;">
        <span>Image source</span>
        <select id="imgSrcSel">
          <option value="obs" selected>obs</option>
          <option value="next_obs">next_obs</option>
        </select>
      </div>
      <div class="check-row" style="margin-bottom:6px;">
        <button id="selectAllCams" class="btn">Select all</button>
        <button id="clearCams" class="btn">Clear</button>
      </div>
      <div id="camChecklist" class="checklist"></div>
      <div class="hint mini">Cards auto‚Äëlayout. Toggle anytime.</div>
    </div>

    <div>
      <h3>Advanced signals</h3>
      <div class="checklist" id="advSignals"></div>
      <div class="hint mini">Overlay vel/torques/TCP/actions/goal/cube (opt‚Äëin).</div>
    </div>

    <div>
      <h3>Performance</h3>
      <label class="field"><input id="fastMode" type="checkbox" checked/> <span>Fast mode (downsample plots)</span></label>
    </div>

    <div>
      <h3>Export</h3>
      <div class="checklist">
        <label><input id="renumberToggle" type="checkbox" checked/> <span>Renumber demos to demo_00000..</span></label>
      </div>
      <div class="check-row" style="margin-top:6px;">
        <button id="downloadOrigBtn" class="btn" title="Download original upload">‚¨á Original</button>
        <button id="downloadPrunedBtn" class="btn" title="Download pruned HDF5">‚¨á Pruned</button>
      </div>
      <div class="check-row" style="margin-top:6px;">
        <button id="downloadScriptBtn" class="btn" title="Download pruning Python script">‚¨á Python script</button>
      </div>
    </div>
  </aside>

  <!-- Header -->
  <header>
    <div class="title">
      <span class="badge">Dexsuite</span>
      <span>HDF5 Visualizer ‚Äî Pro</span>
    </div>
    <div style="display:flex; align-items:center; gap:12px;">
      <div class="kpi">
        <div>Demo: <strong id="demoName">‚Äî</strong></div>
        <div>Frames: <strong id="kpiFrames">0</strong></div>
        <div>Span: <strong id="kpiTime">0.00s</strong></div>
      </div>
      <button id="themeToggle" class="toggle" title="Toggle theme">üåô</button>
    </div>
  </header>

  <!-- Main -->
  <section class="main">
    <section class="cameras" id="camsGrid"></section>
    <section class="plots">
      <div class="plot-card"><div id="gripperPlot" class="plot"></div></div>
      <div class="plot-card"><div id="manipPlot" class="plot"></div></div>
      <div class="plot-card"><div id="eefPlot" class="plot"></div></div>
    </section>
  </section>

  <!-- Controls (scrolls with page) -->
  <section class="controls">
    <button id="playBtn" class="play">‚ñ∂ Play</button>
    <input id="mainSlider" class="slider" type="range" min="0" value="0" max="1" step="1"/>
    <span class="tag">t = <b id="kpiT">0</b> / <span id="kpiTMax">0</span></span>
    <span class="spacer"></span>
    <span class="tag" id="envTag">env: ‚Äî</span>
    <div class="field" style="margin-left:auto">
      <span>Œît</span><input id="dtInput" type="number" min="0.001" step="0.001" value="0.01"/>
      <span class="mini">s/step</span>
      <span style="width:10px"></span>
      <span>Speed</span>
      <select id="speedSel">
        <option value="0.25">0.25√ó</option>
        <option value="0.5">0.5√ó</option>
        <option value="1" selected>1√ó</option>
        <option value="2">2√ó</option>
        <option value="4">4√ó</option>
      </select>
    </div>
  </section>
</div>

<!-- Progress overlay for export -->
<div class="overlay" id="overlay">
  <div class="box">
    <div id="overlayMsg">Preparing export‚Ä¶</div>
    <div class="progress"><div class="bar" id="overlayBar"></div></div>
  </div>
</div>

<!-- App logic -->
<script type="module">
  import h5wasm from "https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5_hl.js";
  import { uploader, UPLOADED_FILES, download } from "https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/file_handlers.js";
  const Module = await h5wasm.ready;

  // ---- UI refs
  const body = document.body;
  const themeToggle = document.getElementById('themeToggle');
  const fileInput = document.getElementById('fileInput');
  const downloadOrigBtn = document.getElementById('downloadOrigBtn');
  const downloadPrunedBtn = document.getElementById('downloadPrunedBtn');
  const downloadScriptBtn = document.getElementById('downloadScriptBtn');
  const renumberToggle = document.getElementById('renumberToggle');
  const fastModeCB = document.getElementById('fastMode');
  const fileInfo  = document.getElementById('fileInfo');

  const demoChips = document.getElementById('demoChips');
  const demoName  = document.getElementById('demoName');

  const camsGrid  = document.getElementById('camsGrid');
  const camChecklist = document.getElementById('camChecklist');
  const selectAllCams = document.getElementById('selectAllCams');
  const clearCams = document.getElementById('clearCams');
  const imgSrcSel = document.getElementById('imgSrcSel');

  const gripperPlotEl = document.getElementById('gripperPlot');
  const manipPlotEl   = document.getElementById('manipPlot');
  const eefPlotEl     = document.getElementById('eefPlot');

  const dtInput  = document.getElementById('dtInput');
  const speedSel = document.getElementById('speedSel');
  const playBtn  = document.getElementById('playBtn');
  const slider   = document.getElementById('mainSlider');
  const kpiFrames= document.getElementById('kpiFrames');
  const kpiTime  = document.getElementById('kpiTime');
  const kpiT     = document.getElementById('kpiT');
  const kpiTMax  = document.getElementById('kpiTMax');
  const envTag   = document.getElementById('envTag');

  const overlay = document.getElementById('overlay');
  const overlayMsg = document.getElementById('overlayMsg');
  const overlayBar = document.getElementById('overlayBar');

  // ---- State
  let h5file = null;
  let sourceFilename = null;

  // Map UI-renumbered names <-> original names
  // uiNames: ["demo_00000","demo_00001", ...] -> srcNames: ["demo_00004", "demo_00001", ...]
  let uiNames = [];
  let srcNames = [];
  let include = new Set();   // UI names included for export
  let removed = new Set();   // UI names removed (session only)
  let currentUI = null;

  const state = {
    imageSrc: 'obs',
    availableCams: [], selectedCams: [], camDS: {},
    // time-series datasets
    g_qpos:null, g_qvel:null, g_qtorque:null, g_tcp_pose:null,
    m_qpos:null, m_qvel:null, m_qtorque:null,
    eef_pose:null, other_goal:null, other_cube:null, actions:null,
    T:0, H:224, W:224, t:0,
    _eefX:[], _eefY:[], _eefZ:[]
  };

  const playback = { running:false, speed:1.0, dt:0.01, raf:null, last:0, acc:0 };

  // ---- Helpers
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const range = n => Array.from({length:n}, (_,i)=>i);
  const nextTick =()=> new Promise(r=>setTimeout(r,0));
  const verticalLine = (x, color="#0066ff") => [{ type:"line", x0:x,x1:x,y0:0,y1:1, xref:"x", yref:"paper", line:{color, width:2, dash:"dot"} }];
  function sec(n){ return (Math.round(n*100)/100).toFixed(2) + "s"; }

  // Canvas buffers cache (speed)
  const canvasCache = new Map(); // name -> { tmp, ctx, rgba, lastW, lastH }
  function getCanvasBuffers(name, W, H){
    const key = `${name}:${W}x${H}`;
    let c = canvasCache.get(key);
    if(!c){
      const tmp = document.createElement('canvas');
      tmp.width = W; tmp.height = H;
      const ctx = tmp.getContext('2d', { willReadFrequently:false });
      const rgba = new Uint8ClampedArray(W*H*4);
      c = { tmp, ctx, rgba, lastW:W, lastH:H };
      canvasCache.set(key, c);
    }
    return c;
  }
  function drawRGBToCanvas(canvas, flat, W, H){
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const { tmp, ctx:tmpCtx, rgba } = getCanvasBuffers(canvas.id, W, H);
    // fill RGBA (reuse buffer)
    for(let i=0, j=0; i<W*H; i++){
      rgba[j++] = flat[i*3+0];
      rgba[j++] = flat[i*3+1];
      rgba[j++] = flat[i*3+2];
      rgba[j++] = 255;
    }
    tmpCtx.putImageData(new ImageData(rgba, W, H), 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(tmp, 0, 0, rect.width, rect.height);
  }

  // ---- Theme toggle
  function setTheme(next){
    body.setAttribute('data-theme', next);
    themeToggle.textContent = (next === 'dark') ? 'üåô' : '‚òÄÔ∏è';
    const tpl = (next === 'dark') ? 'plotly_dark' : 'plotly_white';
    const common = { template: tpl, paper_bgcolor:'transparent', plot_bgcolor:'transparent' };
    Plotly.relayout(gripperPlotEl, common);
    Plotly.relayout(manipPlotEl,   common);
    Plotly.relayout(eefPlotEl,     common);
  }
  themeToggle.addEventListener('click', ()=>{
    const curr = body.getAttribute('data-theme') || 'dark';
    setTheme(curr === 'dark' ? 'light' : 'dark');
  });

  // ---- File loading
  fileInput.addEventListener('change', async (e)=>{
    await uploader(e);
    sourceFilename = UPLOADED_FILES.at(-1);
    h5file?.close?.();
    h5file = new h5wasm.File(sourceFilename, "r");
    fileInfo.textContent = `Loaded: ${sourceFilename}`;
    initFile();
  });

  // Download original
  downloadOrigBtn.addEventListener('click', ()=> { if(h5file) download(h5file); });

  // ---- Read structure and build UI (renumbered list)
  function listSrcDemos(){
    const keys = h5file.get('data').keys();
    return keys.filter(k=>k.startsWith('demo_')).sort((a,b)=>{
      const ia = parseInt(a.split('_').pop().replace(/^0+/,'' )||'0',10);
      const ib = parseInt(b.split('_').pop().replace(/^0+/,'' )||'0',10);
      return ia - ib;
    });
  }
  function buildMappings(){
    srcNames = listSrcDemos();
    uiNames = srcNames.map((_,i)=> `demo_${String(i).padStart(5,'0')}`);
  }
  function uiToSrc(ui){ const idx = uiNames.indexOf(ui); return idx>=0 ? srcNames[idx] : null; }
  function srcToUi(src){ const idx = srcNames.indexOf(src); return idx>=0 ? uiNames[idx] : null; }

  function buildDemoChip(uiName){
    const div = document.createElement('div'); div.className='chip';
    const left = document.createElement('div'); left.className='left';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = !removed.has(uiName) && include.has(uiName);
    const label = document.createElement('span'); label.textContent = uiName;
    const small = document.createElement('span'); small.className='mini'; small.textContent = ` (${uiToSrc(uiName)})`;
    const rm = document.createElement('span'); rm.className='remove'; rm.textContent='üóë';

    left.appendChild(cb); left.appendChild(label); left.appendChild(small);
    left.addEventListener('click', (ev)=>{ if(ev.target!==cb) selectDemo(uiName); });
    cb.addEventListener('change', ()=>{ if(cb.checked) include.add(uiName); else include.delete(uiName); });
    rm.addEventListener('click', ()=>{
      removed.add(uiName); include.delete(uiName);
      if(currentUI===uiName) currentUI = null;
      initFile();
    });
    div.appendChild(left); div.appendChild(rm);
    return div;
  }

  function initFile(){
    buildMappings();
    // default include all visible (not removed)
    if(include.size===0) uiNames.forEach(n=> { if(!removed.has(n)) include.add(n); });
    // rebuild list
    demoChips.innerHTML='';
    uiNames.forEach(ui=>{
      if(removed.has(ui)) return;
      demoChips.appendChild(buildDemoChip(ui));
    });

    // env tag
    let env = '‚Äî';
    try{
      const envArgs = h5file.get('data').attrs['env_args']?.value;
      if(envArgs) {
        const meta = (typeof envArgs === 'string') ? JSON.parse(envArgs) : envArgs;
        env = (meta.env_name || meta.env || '‚Äî');
      }
    }catch(_){}
    document.getElementById('envTag').textContent = `env: ${env}`;

    // select first available
    const first = uiNames.find(n=>!removed.has(n));
    if(first) selectDemo(first);
  }

  // discover cameras under obs
  function discoverCameras(uiName){
    const src = uiToSrc(uiName);
    const obs = h5file.get(`data/${src}/obs`);
    const keys = obs.keys();
    const cams = keys.filter(k=>k.endsWith('_image'));

    // defaults: prefer the classic four
    const pref = ["front_image","left_side_image","overhead_image","right_side_image"];
    const sel = []; pref.forEach(p=>{ if(cams.includes(p)) sel.push(p); });
    const rem = cams.filter(k=>!sel.includes(k)).slice(0, Math.max(0, 4 - sel.length));
    return { cams, selected: [...sel, ...rem].slice(0,8) };
  }

  async function selectDemo(uiName){
    currentUI = uiName;
    demoName.textContent = uiName;

    state.imageSrc = imgSrcSel.value || 'obs';
    const { cams, selected } = discoverCameras(uiName);
    state.availableCams = cams.slice(0,8);
    state.selectedCams = selected;
    state.camDS = {};

    // checklist
    camChecklist.innerHTML='';
    state.availableCams.forEach((name,i)=>{
      const id = `cam_${i}`;
      const row = document.createElement('label');
      row.innerHTML = `<input type="checkbox" id="${id}" ${selected.includes(name)?'checked':''}> <span>${name}</span>`;
      camChecklist.appendChild(row);
      document.getElementById(id).addEventListener('change', rebuildCams);
    });
    selectAllCams.onclick = ()=>{ [...camChecklist.querySelectorAll('input')].forEach(cb=>cb.checked=true); rebuildCams(); };
    clearCams.onclick = ()=>{ [...camChecklist.querySelectorAll('input')].forEach(cb=>cb.checked=false); rebuildCams(); };

    // timeseries (from obs)
    const src = uiToSrc(uiName);
    const base = `data/${src}/obs`;
    const safeGet = (k)=>{ try{ return h5file.get(`${base}/${k}`); } catch{ return null; } };
    state.g_qpos    = safeGet('gripper_qpos');
    state.g_qvel    = safeGet('gripper_qvel');
    state.g_qtorque = safeGet('gripper_qtorque');
    state.g_tcp_pose= safeGet('gripper_tcp_pose');

    state.m_qpos    = safeGet('manipulator_qpos');
    state.m_qvel    = safeGet('manipulator_qvel');
    state.m_qtorque = safeGet('manipulator_qtorque');

    state.eef_pose  = safeGet('manipulator_eef_pose');
    state.other_goal= safeGet('other_goal_pos');
    state.other_cube= safeGet('other_cube_pos');

    try{ state.actions = h5file.get(`data/${src}/actions`); } catch{ state.actions = null; }

    buildAdvancedSignals();
    rebuildCams();
    await buildPlots();
    await renderFrame(0, true);

    const dt = Number(dtInput.value) || 0.01;
    kpiTime.textContent = sec(state.T * dt);
  }

  function buildAdvancedSignals(){
    const adv = document.getElementById('advSignals');
    adv.innerHTML='';
    const options = [
      { id:'gvel', label:'gripper_qvel', present: !!state.g_qvel, group:'gripper' },
      { id:'gtau', label:'gripper_qtorque', present: !!state.g_qtorque, group:'gripper' },
      { id:'gtcp', label:'gripper_tcp_pose', present: !!state.g_tcp_pose, group:'gripper' },
      { id:'mvel', label:'manipulator_qvel', present: !!state.m_qvel, group:'manip' },
      { id:'mtau', label:'manipulator_qtorque', present: !!state.m_qtorque, group:'manip' },
      { id:'act',  label:'actions', present: !!state.actions, group:'manip' },
      { id:'goal', label:'other_goal_pos (3D markers)', present: !!state.other_goal, group:'eef' },
      { id:'cube', label:'other_cube_pos (3D markers)', present: !!state.other_cube, group:'eef' },
    ];
    options.forEach(opt=>{
      if(!opt.present) return;
      const lab = document.createElement('label');
      lab.innerHTML = `<input type="checkbox" data-group="${opt.group}" data-id="${opt.id}"> <span>${opt.label}</span>`;
      adv.appendChild(lab);
    });
    adv.addEventListener('change', ()=> buildPlots());
  }

  function rebuildCams(){
    // selected
    state.selectedCams = [];
    [...camChecklist.querySelectorAll('label')].forEach(row=>{
      const cb = row.querySelector('input'); const name = row.querySelector('span').textContent;
      if(cb.checked) state.selectedCams.push(name);
    });

    // datasets from current image source
    const src = uiToSrc(currentUI);
    const base = `data/${src}/${state.imageSrc}`;
    state.camDS = {};
    for(const name of state.selectedCams){
      try{ state.camDS[name] = h5file.get(`${base}/${name}`); } catch(_){}
    }

    // camera cards
    camsGrid.innerHTML='';
    state.selectedCams.forEach(name=>{
      const card = document.createElement('div'); card.className = 'cam-card';
      const tag  = document.createElement('div'); tag.className = 'cam-label'; tag.textContent = name;
      const canvas = document.createElement('canvas'); canvas.id = `canvas_${name}`;
      card.appendChild(tag); card.appendChild(canvas); camsGrid.appendChild(card);
    });

    // T/H/W
    let T = Infinity, H = 224, W = 224;
    if(state.g_qpos)   T = Math.min(T, state.g_qpos.shape[0]);
    if(state.m_qpos)   T = Math.min(T, state.m_qpos.shape[0]);
    if(state.eef_pose) T = Math.min(T, state.eef_pose.shape[0]);
    for(const name of state.selectedCams){
      const ds = state.camDS[name]; if(!ds) continue;
      T = Math.min(T, ds.shape[0]); H = ds.shape[1]; W = ds.shape[2];
    }
    if(!isFinite(T)) T = 0;
    state.T = T; state.H = H; state.W = W; state.t = 0;
    slider.max = String(Math.max(0, T-1)); slider.value = "0";
    kpiFrames.textContent = String(T); kpiTMax.textContent = String(Math.max(0, T-1));
  }

  imgSrcSel.addEventListener('change', ()=>{
    state.imageSrc = imgSrcSel.value;
    rebuildCams();
    renderFrame(0, true);
  });

  // ---- Faster plot builders (optional downsampling)
  const MAX_PLOT_POINTS = 1500;
  function maybeDownsample(xArr, seriesArrays){
    if(!fastModeCB.checked) return { x:xArr, ys:seriesArrays };
    const T = xArr.length;
    if(T <= MAX_PLOT_POINTS) return { x:xArr, ys:seriesArrays };
    const stride = Math.ceil(T / MAX_PLOT_POINTS);
    const xs = [], ys = seriesArrays.map(()=>[]);
    for(let t=0;t<T;t+=stride){
      xs.push(xArr[t]);
      for(let j=0;j<seriesArrays.length;j++) ys[j].push(seriesArrays[j][t]);
    }
    return { x:xs, ys };
  }

  async function buildPlots(){
    const T = state.T, tvec = range(T);
    const tpl = (body.getAttribute('data-theme')==='dark') ? 'plotly_dark' : 'plotly_white';
    const common = { template: tpl, margin:{l:40,r:8,t:24,b:28}, paper_bgcolor:'transparent', plot_bgcolor:'transparent' };
    const advOn = id => !!document.querySelector(`#advSignals input[data-id="${id}"]`)?.checked;

    // Gripper
    const gpTraces = [];
    if(state.g_qpos){
      const D = state.g_qpos.shape[1], flat = state.g_qpos.value; // small arrays, OK
      const ys = [];
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y);
      }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> gpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`q${j}`, line:{width:1.6} }));
    }
    if(advOn('gvel') && state.g_qvel){
      const D = state.g_qvel.shape[1], flat = state.g_qvel.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> gpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`vel${j}`, line:{width:1, dash:'dot'} }));
    }
    if(advOn('gtau') && state.g_qtorque){
      const D = state.g_qtorque.shape[1], flat = state.g_qtorque.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> gpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`tau${j}`, line:{width:1, dash:'dash'} }));
    }
    if(advOn('gtcp') && state.g_tcp_pose){
      const D = state.g_tcp_pose.shape[1], flat = state.g_tcp_pose.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> gpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`tcp${j}`, line:{width:1, dash:'dot'} }));
    }
    await Plotly.react(gripperPlotEl, gpTraces, {
      ...common, showlegend:true, legend:{orientation:'h', yanchor:'bottom', y:1.02, x:0},
      xaxis:{ title:'timestep', rangemode:'nonnegative', showgrid:true },
      yaxis:{ title:'gripper', showgrid:true },
      shapes: verticalLine(0)
    }, {displayModeBar:false, responsive:true});

    // Manip
    const mpTraces = [];
    if(state.m_qpos){
      const D = state.m_qpos.shape[1], flat = state.m_qpos.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> mpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`q${j}`, line:{width:1.6} }));
    }
    if(advOn('mvel') && state.m_qvel){
      const D = state.m_qvel.shape[1], flat = state.m_qvel.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> mpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`vel${j}`, line:{width:1, dash:'dot'} }));
    }
    if(advOn('mtau') && state.m_qtorque){
      const D = state.m_qtorque.shape[1], flat = state.m_qtorque.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> mpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`tau${j}`, line:{width:1, dash:'dash'} }));
    }
    if(advOn('act') && state.actions){
      const D = state.actions.shape[1], flat = state.actions.value;
      const ys = [];
      for(let j=0;j<D;j++){ const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j]; ys.push(y); }
      const ds = maybeDownsample(tvec, ys);
      ds.ys.forEach((y, j)=> mpTraces.push({ x:ds.x, y, type:'scatter', mode:'lines', name:`a${j}`, line:{width:1, dash:'dot'} }));
    }
    await Plotly.react(manipPlotEl, mpTraces, {
      ...common, showlegend:true, legend:{orientation:'h', yanchor:'bottom', y:1.02, x:0},
      xaxis:{ title:'timestep', rangemode:'nonnegative', showgrid:true },
      yaxis:{ title:'manipulator', showgrid:true },
      shapes: verticalLine(0)
    }, {displayModeBar:false, responsive:true});

    // EEF 3D (downsample in fast mode)
    const x=[], y=[], z=[];
    if(state.eef_pose){
      const flat = state.eef_pose.value;
      for(let t=0;t<T;t++){ x.push(flat[t*6+0]); y.push(flat[t*6+1]); z.push(flat[t*6+2]); }
    }
    let x3=x, y3=y, z3=z;
    if(fastModeCB.checked && x.length>MAX_PLOT_POINTS){
      const stride = Math.ceil(x.length / MAX_PLOT_POINTS);
      x3 = []; y3 = []; z3 = [];
      for(let i=0;i<x.length;i+=stride){ x3.push(x[i]); y3.push(y[i]); z3.push(z[i]); }
    }
    const traces = [
      { type:'scatter3d', mode:'lines', x:x3, y:y3, z:z3, line:{width:2, color:'rgba(0,102,255,0.25)'}, name:'full' },
      { type:'scatter3d', mode:'lines', x:[x3[0]], y:[y3[0]], z:[z3[0]], line:{width:4, color:'rgba(0,102,255,1.0)'}, name:'played' },
      { type:'scatter3d', mode:'markers', x:[x3[0]], y:[y3[0]], z:[z3[0]], marker:{size:3}, name:'current' }
    ];
    if(document.querySelector('#advSignals input[data-id="goal"]')?.checked && state.other_goal){
      const g = state.other_goal.value; const gx=[], gy=[], gz=[];
      for(let t=0;t<T;t++){ gx.push(g[t*3+0]); gy.push(g[t*3+1]); gz.push(g[t*3+2]); }
      if(fastModeCB.checked && gx.length>MAX_PLOT_POINTS){
        const stride = Math.ceil(gx.length / MAX_PLOT_POINTS);
        const gx2=[], gy2=[], gz2=[]; for(let i=0;i<gx.length;i+=stride){ gx2.push(gx[i]); gy2.push(gy[i]); gz2.push(gz[i]); }
        traces.push({ type:'scatter3d', mode:'markers', x:gx2, y:gy2, z:gz2, marker:{size:2}, name:'goal' });
      } else {
        traces.push({ type:'scatter3d', mode:'markers', x:gx, y:gy, z:gz, marker:{size:2}, name:'goal' });
      }
    }
    if(document.querySelector('#advSignals input[data-id="cube"]')?.checked && state.other_cube){
      const c = state.other_cube.value; const cx=[], cy=[], cz=[];
      for(let t=0;t<T;t++){ cx.push(c[t*3+0]); cy.push(c[t*3+1]); cz.push(c[t*3+2]); }
      if(fastModeCB.checked && cx.length>MAX_PLOT_POINTS){
        const stride = Math.ceil(cx.length / MAX_PLOT_POINTS);
        const cx2=[], cy2=[], cz2=[]; for(let i=0;i<cx.length;i+=stride){ cx2.push(cx[i]); cy2.push(cy[i]); cz2.push(cz[i]); }
        traces.push({ type:'scatter3d', mode:'markers', x:cx2, y:cy2, z:cz2, marker:{size:2}, name:'cube' });
      } else {
        traces.push({ type:'scatter3d', mode:'markers', x:cx, y:cy, z:cz, marker:{size:2}, name:'cube' });
      }
    }
    const xr = x3.length? [Math.min(...x3), Math.max(...x3)] : [0,1];
    const yr = y3.length? [Math.min(...y3), Math.max(...y3)] : [0,1];
    const zr = z3.length? [Math.min(...z3), Math.max(...z3)] : [0,1];
    const pad = (a,b)=> (b-a)*0.05 || 0.05;
    await Plotly.react(eefPlotEl, traces, {
      ...common, margin:{l:0,r:0,t:26,b:0}, showlegend:false,
      scene:{
        xaxis:{ title:'X (m)', range:[xr[0]-pad(xr[0],xr[1]), xr[1]+pad(xr[0],xr[1])] },
        yaxis:{ title:'Y (m)', range:[yr[0]-pad(yr[0],yr[1]), yr[1]+pad(yr[0],yr[1])] },
        zaxis:{ title:'Z (m)', range:[zr[0]-pad(zr[0],zr[1]), zr[1]+pad(zr[0],zr[1])] },
        aspectmode:'cube', bgcolor:'rgba(0,0,0,0)'
      }
    }, {displayModeBar:false, responsive:true});

    state._eefX = x; state._eefY = y; state._eefZ = z;
  }

  // ---- Frame render
  async function renderFrame(t, force=false){
    t = clamp(t, 0, Math.max(0, state.T - 1));
    if(!force && t === state.t) return;
    state.t = t;
    slider.value = String(t); kpiT.textContent = String(t);

    // Cameras: single-frame slice
    for(const name of state.selectedCams){
      const ds = state.camDS[name]; if(!ds) continue;
      const W = state.W, H = state.H;
      const flat = ds.slice([[t,t+1],[0,H],[0,W],[0,3]]);
      const canvas = document.getElementById(`canvas_${name}`);
      if(canvas) drawRGBToCanvas(canvas, flat, W, H);
    }

    // cursor lines
    Plotly.relayout(gripperPlotEl, { shapes: verticalLine(t) });
    Plotly.relayout(manipPlotEl,   { shapes: verticalLine(t) });

    // EEF played path + current point
    if(state._eefX.length){
      const px = state._eefX.slice(0,t+1), py = state._eefY.slice(0,t+1), pz = state._eefZ.slice(0,t+1);
      Plotly.restyle(eefPlotEl, { x:[px], y:[py], z:[pz] }, [1]);
      Plotly.restyle(eefPlotEl, { x:[[state._eefX[t]]], y:[[state._eefY[t]]], z:[[state._eefZ[t]]] }, [2]);
    }
  }

  // ---- Playback
  function updateTiming(){ playback.dt = Math.max(0.001, Number(dtInput.value) || 0.01); playback.speed = Number(speedSel.value) || 1.0; }
  dtInput.addEventListener('change', ()=>{ updateTiming(); kpiTime.textContent = sec(state.T * playback.dt); });
  speedSel.addEventListener('change', ()=> updateTiming());

  function start(){
    if(playback.running || state.T===0) return;
    updateTiming(); playback.running = true; playBtn.textContent = '‚è∏ Pause';
    playback.last = performance.now(); playback.acc = 0;
    const period = ()=> 1000 * playback.dt / playback.speed;
    const tick = (now)=>{
      if(!playback.running) return;
      const elapsed = now - playback.last; playback.last = now; playback.acc += elapsed;
      const per = period();
      while(playback.acc >= per){ playback.acc -= per; const next = (state.t + 1) % Math.max(1, state.T); renderFrame(next); }
      playback.raf = requestAnimationFrame(tick);
    };
    playback.raf = requestAnimationFrame(tick);
  }
  function stop(){
    if(!playback.running) return;
    playback.running = false; playBtn.textContent = '‚ñ∂ Play';
    if(playback.raf) cancelAnimationFrame(playback.raf); playback.raf = null;
  }
  playBtn.addEventListener('click', ()=> playback.running ? stop() : start());
  slider.addEventListener('input', ()=> renderFrame(Number(slider.value), true));
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); playback.running ? stop() : start(); } if(e.code==='ArrowRight'){ stop(); renderFrame(state.t+1, true); } if(e.code==='ArrowLeft'){ stop(); renderFrame(state.t-1, true); } });

  window.addEventListener('resize', ()=>{ Plotly.Plots.resize(gripperPlotEl); Plotly.Plots.resize(manipPlotEl); Plotly.Plots.resize(eefPlotEl); });

  // ---- Export helpers
  function showOverlay(msg, p){ overlay.style.display='flex'; overlayMsg.textContent = msg; overlayBar.style.width = (p||0)+'%'; }
  function hideOverlay(){ overlay.style.display='none'; }
  function getIncludedUINames(){ return uiNames.filter(n => include.has(n) && !removed.has(n)); }

  // Pruned export (renumbered)
  downloadPrunedBtn.addEventListener('click', async ()=>{
    if(!h5file) return;
    const keepUI = getIncludedUINames();
    if(keepUI.length===0){ alert('No demos selected (‚úì).'); return; }

    const renumber = renumberToggle.checked;
    const baseName = (sourceFilename || 'dataset.hdf5').split('/').pop();
    const outName = `pruned_${baseName}`;
    showOverlay('Creating pruned HDF5‚Ä¶', 0);

    const out = new h5wasm.File(outName, 'w');
    const outData = out.create_group('data');
    const inData = h5file.get('data');

    // copy env_args if present
    try{
      const envArgs = inData.attrs['env_args']?.value;
      if(envArgs !== undefined) outData.create_attribute('env_args', envArgs);
    }catch(_){}

    // recursive copy: copy srcPath into dstGroup (preserving structure)
    async function copyTree(srcPath, dstGroup){
      const obj = h5file.get(srcPath);
      // datasets vs groups
      if(obj.keys){
        // group
        const name = srcPath.split('/').pop();
        const g = dstGroup.create_group(name);
        // copy attrs
        try{
          const attrs = obj.attrs || {};
          for(const k of Object.keys(attrs)){ g.create_attribute(k, attrs[k].value); }
        }catch(_){}
        for(const k of obj.keys()){
          await copyTree(`${srcPath}/${k}`, g);
        }
      } else {
        // dataset (read once; write once)
        const data = obj.value;
        const name = srcPath.split('/').pop();
        const args = { name, data, shape: obj.shape, dtype: obj.dtype };
        try{
          if((obj.filters||[]).some(f=>f.name==='deflate')){ args.compression='gzip'; args.compression_opts=[4]; }
        }catch(_){}
        dstGroup.create_dataset(args);
      }
      await nextTick();
    }

    // map UI ‚Üí export name
    const expNames = keepUI.map((_,i)=> `demo_${String(i).padStart(5,'0')}`);
    // copy demos
    let total = 0;
    for(let i=0;i<keepUI.length;i++){
      const ui = keepUI[i];
      const src = uiToSrc(ui);
      const srcDemoPath = `data/${src}`;
      const dstDemoName = renumber ? expNames[i] : src;  // renumber or keep original
      overlayMsg.textContent = `Copying ${dstDemoName}‚Ä¶`; overlayBar.style.width = Math.round(100*(i/keepUI.length))+'%';

      // create container group with proper name
      const g = outData.create_group(dstDemoName);
      // copy demo attrs
      try{
        const gIn = h5file.get(srcDemoPath);
        const attrs = gIn.attrs || {};
        for(const k of Object.keys(attrs)){ g.create_attribute(k, attrs[k].value); }
        total += (gIn.attrs['num_samples']?.value || 0);
      }catch(_){}
      // copy subtree
      await copyTree(srcDemoPath, outData); // places /data/<src>/*
      if(renumber && dstDemoName !== src){
        // If renumbering, we just created /data/<src>/* above; move it under /data/<dstDemoName>
        // Simpler: delete empty g and rename group by creating new and copying children again, but h5wasm lacks rename.
        // Workaround: we already made 'g' with attrs; now move children from /data/<src> into g.
        const tempGroup = outData.get(src);
        for(const k of tempGroup.keys()){ await copyTree(`data/${src}/${k}`, g); }
        // best-effort remove the temporary /data/<src> group by ignoring it in final file (cannot delete in h5wasm HL safely).
      }
      await nextTick();
    }

    outData.create_attribute('total', Number(total));
    hideOverlay();
    download(out);
    out.close();
  });

  // Python script export (prune + renumber offline)
  downloadScriptBtn.addEventListener('click', ()=>{
    if(!h5file) return;
    const keepUI = getIncludedUINames();
    if(keepUI.length===0){ alert('No demos selected (‚úì).'); return; }
    const renumber = renumberToggle.checked;
    const keepSrc = keepUI.map(ui=> uiToSrc(ui));

    const py = `#!/usr/bin/env python3
import argparse, h5py, numpy as np, sys

def copy_attrs(src, dst):
    for k,v in src.attrs.items():
        try: dst.attrs[k] = v
        except: pass

def copy_tree(infile, outfile, src_path, dst_group):
    obj = infile[src_path]
    if isinstance(obj, h5py.Group):
        name = src_path.split('/')[-1]
        g = dst_group.create_group(name)
        copy_attrs(obj, g)
        for k in obj.keys():
            copy_tree(infile, outfile, src_path + '/' + k, g)
    else:
        # dataset
        name = src_path.split('/')[-1]
        d = dst_group.create_dataset(name, data=obj[...], compression='gzip', compression_opts=4)
        copy_attrs(obj, d)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--input', required=True)
    ap.add_argument('--output', required=True)
    ap.add_argument('--no-renumber', action='store_true', help='keep original demo names')
    args = ap.parse_args()

    keep_src = ${JSON.stringify(keepSrc, null, 2)}
    do_renum = ${renumber ? 'True' : 'False'} and (not args.no_renumber)

    with h5py.File(args.input, 'r') as fin, h5py.File(args.output, 'w') as fout:
        data_in  = fin['data']
        data_out = fout.create_group('data')

        # env_args
        if 'env_args' in data_in.attrs:
            data_out.attrs['env_args'] = data_in.attrs['env_args']

        total = 0
        for i, src in enumerate(keep_src):
            out_name = src if not do_renum else f'demo_{i:05d}'
            # create group and copy attrs
            g_in  = data_in[src]
            g_out = data_out.create_group(out_name)
            copy_attrs(g_in, g_out)
            total += int(g_in.attrs.get('num_samples', 0))
            # copy children
            for k in g_in.keys():
                copy_tree(fin, fout, f'data/{src}/{k}', g_out)

        data_out.attrs['total'] = total

if __name__ == '__main__':
    main()
`;
    const blob = new Blob([py], {type:'text/x-python'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'prune_renumber.py';
    document.body.appendChild(a); a.click(); a.remove();
  });

  // Initialize defaults
  setTheme('dark');
</script>
</body>
</html>
