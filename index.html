<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Dexsuite Data Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<!-- Plotly -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<!-- Fonts -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

<style>
  /* ====== THEME (dark / light) ====== */
  :root{
    --bg: #0b0e10; --panel:#12161a; --card:#0f1317; --ring:#222a32; --muted:#9bb0c2; --fg:#eaf3ff;
    --accent:#0066ff; --accent-2:#68b2ff; --chip:#1b2128; --chip-hover:#222a32; --plot-bg:#0b0e10;
  }
  [data-theme="light"]{
    --bg:#ffffff; --panel:#f6f8fb; --card:#ffffff; --ring:#e3e8ef; --muted:#5b6b7a; --fg:#0d1117;
    --accent:#0066ff; --accent-2:#7dbdff; --chip:#eef3f9; --chip-hover:#e7edf6; --plot-bg:#ffffff;
  }
  *{ box-sizing:border-box; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif }
  .app{
    display:grid; grid-template-columns: 300px 1fr;
    grid-template-rows: auto 1fr auto;
    grid-template-areas:
      "sidebar header"
      "sidebar main"
      "controls controls";
    gap:16px; height:100vh; padding:16px;
  }
  header{
    grid-area:header; display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px; background:var(--panel); border:1px solid var(--ring); border-radius:14px;
  }
  .title{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; }
  .badge{ padding:4px 10px; border-radius:999px; background:linear-gradient(135deg, var(--accent), var(--accent-2)); color:white; font-size:12px; }
  .kpi{ display:flex; gap:18px; align-items:center; color:var(--muted); font-size:13px; }
  .kpi strong{ color:var(--fg); }
  .toggle{
    border:1px solid var(--ring); background:var(--card); color:var(--fg);
    padding:8px 12px; border-radius:10px; cursor:pointer;
  }
  .toolbar .btn{ margin-right:8px; }

  .sidebar{
    grid-area:sidebar; display:flex; flex-direction:column; gap:14px; padding:12px;
    background:var(--panel); border:1px solid var(--ring); border-radius:14px; min-height:0;
  }
  .sidebar h3{ margin:0 0 6px; font-size:12px; color:var(--muted); font-weight:700; letter-spacing:.5px; text-transform:uppercase; }
  .hint{ color:var(--muted); font-size:12px; }
  .btn{
    display:inline-flex; align-items:center; gap:8px; border:1px solid var(--ring); background:var(--card);
    padding:9px 12px; border-radius:10px; color:var(--fg); cursor:pointer; transition:all .15s ease;
  }
  .btn:hover{ transform:translateY(-1px); background:var(--chip-hover) }
  .toolbar input[type=file]{ display:none; }
  .field{
    display:flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--ring);
    background:var(--card); border-radius:10px;
  }
  .field input, .field select{
    background:transparent; border:none; color:var(--fg); outline:none; font:inherit;
  }

  /* Demo chips with include toggle + remove */
  .chips{ display:flex; flex-direction:column; gap:8px; overflow:auto; padding-right:4px; }
  .chip{
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    padding:9px 12px; border-radius:10px; background:var(--chip); border:1px solid var(--ring);
    user-select:none; transition:all .15s ease; font-weight:600; color:#cfe3ff;
  }
  [data-theme="light"] .chip{ color:#114; }
  .chip:hover{ background:var(--chip-hover); }
  .chip .left{ display:flex; align-items:center; gap:10px; cursor:pointer; }
  .chip .remove{ cursor:pointer; opacity:.8; }
  .chip .remove:hover{ opacity:1; filter:brightness(1.2); }

  .checklist{ display:flex; flex-direction:column; gap:6px; padding:8px; max-height:180px; overflow:auto; border:1px dashed var(--ring); border-radius:10px; background:var(--card); }
  .checklist label{ display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px; cursor:pointer; }
  .check-row{ display:flex; gap:8px; }
  .mini{ font-size:12px; color:var(--muted); }

  .main{ grid-area:main; display:grid; grid-template-columns: 1.2fr 1fr; gap:16px; min-height:0; }
  .cameras{
    background:var(--panel); border:1px solid var(--ring); border-radius:14px; padding:12px; min-height:0;
    display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap:12px; align-content:start;
  }
  .cam-card{
    position:relative; background:var(--card); border:1px solid var(--ring); border-radius:12px; overflow:hidden;
    aspect-ratio: 1 / 1;
  }
  .cam-card canvas{ width:100%; height:100%; display:block; }
  .cam-label{ position:absolute; top:8px; left:8px; background:rgba(0,0,0,.55); color:#fff; padding:4px 8px; border-radius:6px; font-size:12px; backdrop-filter: blur(6px); }
  [data-theme="light"] .cam-label{ background:rgba(0,0,0,.45); }

  .plots{ display:grid; grid-template-rows: 220px 220px 1fr; gap:16px; min-height:0; }
  .plot-card{ background:var(--panel); border:1px solid var(--ring); border-radius:14px; overflow:hidden; min-height:0; }
  .plot{ width:100%; height:100%; }

  .controls{
    grid-area:controls; display:flex; gap:12px; align-items:center; padding:12px; background:var(--panel);
    border:1px solid var(--ring); border-radius:14px; flex-wrap:wrap;
  }
  .play{
    padding:10px 16px; border-radius:12px; background:var(--accent); color:white; font-weight:800; border:none; cursor:pointer;
    box-shadow: 0 6px 16px rgba(0,102,255,.35);
  }
  .play:hover{ filter:brightness(1.05) }
  .slider{ flex:1; min-width:200px; }
  input[type=range]{ width:100%; accent-color: var(--accent); }
  .spacer{ flex:1; }
  .tag{ padding:4px 8px; border-radius:8px; background:var(--chip); border:1px solid var(--ring); color:var(--muted); font-size:12px; }

  /* Progress overlay for exports */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); z-index:9999;
  }
  .overlay .box{
    width:min(560px, 92vw); padding:18px; border-radius:12px; background:var(--panel); border:1px solid var(--ring);
  }
  .progress{ height:8px; background:#111; border-radius:6px; overflow:hidden; margin-top:8px; }
  .bar{ height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent-2)); transition:width .2s ease; }
</style>
</head>
<body data-theme="dark">
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div>
      <h3>File</h3>
      <div class="toolbar">
        <label class="btn" for="fileInput">üìÅ Upload HDF5</label>
        <input id="fileInput" type="file" accept=".h5,.hdf5"/>
        <button id="downloadOrigBtn" class="btn" title="Download original upload">‚¨á Original</button>
        <button id="downloadPrunedBtn" class="btn" title="Download only included demos">‚¨á Pruned</button>
      </div>
      <div class="hint" id="fileInfo" style="margin-top:8px;">No file loaded.</div>
    </div>

    <div>
      <h3>Demos</h3>
      <div id="demoChips" class="chips"></div>
      <div class="hint mini">Click a demo name to view. Use ‚úì to include/exclude for export, üóë to remove from this session.</div>
    </div>

    <div>
      <h3>Cameras (select up to 8)</h3>
      <div class="check-row" style="margin-bottom:6px;">
        <button id="selectAllCams" class="btn">Select all</button>
        <button id="clearCams" class="btn">Clear</button>
      </div>
      <div class="field" style="margin-bottom:6px;">
        <span>Image source</span>
        <select id="imgSrcSel">
          <option value="obs" selected>obs</option>
          <option value="next_obs">next_obs</option>
        </select>
      </div>
      <div id="camChecklist" class="checklist"></div>
      <div class="hint mini">Cards auto‚Äëlayout. Toggle on/off anytime.</div>
    </div>

    <div>
      <h3>Advanced signals</h3>
      <div class="checklist" id="advSignals"></div>
      <div class="hint mini">Overlay more series on plots (vel, torque, actions, TCP pose, etc.).</div>
    </div>

    <div>
      <h3>Playback</h3>
      <div class="field">
        <span>Œît</span><input id="dtInput" type="number" min="0.001" step="0.001" value="0.01"/>
        <span class="mini">s/step</span>
      </div>
      <div class="field" style="margin-top:6px;">
        <span>Speed</span>
        <select id="speedSel">
          <option value="0.25">0.25√ó</option>
          <option value="0.5">0.5√ó</option>
          <option value="1" selected>1√ó</option>
          <option value="2">2√ó</option>
          <option value="4">4√ó</option>
        </select>
      </div>
    </div>
  </aside>

  <!-- Header -->
  <header>
    <div class="title">
      <span class="badge">Dexsuite</span>
      <span>HDF5 Visualizer ‚Äî Pro</span>
    </div>
    <div style="display:flex; align-items:center; gap:12px;">
      <div class="kpi">
        <div>Demo: <strong id="demoName">‚Äî</strong></div>
        <div>Frames: <strong id="kpiFrames">0</strong></div>
        <div>Span: <strong id="kpiTime">0.00s</strong></div>
      </div>
      <button id="themeToggle" class="toggle" title="Toggle theme">üåô</button>
    </div>
  </header>

  <!-- Main -->
  <section class="main">
    <section class="cameras" id="camsGrid"></section>

    <section class="plots">
      <div class="plot-card"><div id="gripperPlot" class="plot"></div></div>
      <div class="plot-card"><div id="manipPlot" class="plot"></div></div>
      <div class="plot-card"><div id="eefPlot" class="plot"></div></div>
    </section>
  </section>

  <!-- Controls -->
  <section class="controls">
    <button id="playBtn" class="play">‚ñ∂ Play</button>
    <input id="mainSlider" class="slider" type="range" min="0" value="0" max="1" step="1"/>
    <span class="tag">t = <b id="kpiT">0</b> / <span id="kpiTMax">0</span></span>
    <span class="spacer"></span>
    <span class="tag" id="envTag">env: ‚Äî</span>
  </section>
</div>

<!-- Progress overlay for export -->
<div class="overlay" id="overlay">
  <div class="box">
    <div id="overlayMsg">Preparing export‚Ä¶</div>
    <div class="progress"><div class="bar" id="overlayBar"></div></div>
  </div>
</div>

<!-- App logic -->
<script type="module">
  // HDF5 in the browser (h5wasm)
  import h5wasm from "https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5_hl.js";
  import { uploader, UPLOADED_FILES, download } from "https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/file_handlers.js";
  const Module = await h5wasm.ready; const { FS } = Module;

  // ---- UI refs
  const body = document.body;
  const themeToggle = document.getElementById('themeToggle');
  const fileInput = document.getElementById('fileInput');
  const downloadOrigBtn = document.getElementById('downloadOrigBtn');
  const downloadPrunedBtn = document.getElementById('downloadPrunedBtn');
  const fileInfo  = document.getElementById('fileInfo');

  const demoChips = document.getElementById('demoChips');
  const demoName  = document.getElementById('demoName');

  const camsGrid  = document.getElementById('camsGrid');
  const camChecklist = document.getElementById('camChecklist');
  const selectAllCams = document.getElementById('selectAllCams');
  const clearCams = document.getElementById('clearCams');
  const imgSrcSel = document.getElementById('imgSrcSel');

  const gripperPlotEl = document.getElementById('gripperPlot');
  const manipPlotEl   = document.getElementById('manipPlot');
  const eefPlotEl     = document.getElementById('eefPlot');

  const dtInput  = document.getElementById('dtInput');
  const speedSel = document.getElementById('speedSel');
  const playBtn  = document.getElementById('playBtn');
  const slider   = document.getElementById('mainSlider');
  const kpiFrames= document.getElementById('kpiFrames');
  const kpiTime  = document.getElementById('kpiTime');
  const kpiT     = document.getElementById('kpiT');
  const kpiTMax  = document.getElementById('kpiTMax');
  const envTag   = document.getElementById('envTag');

  const overlay = document.getElementById('overlay');
  const overlayMsg = document.getElementById('overlayMsg');
  const overlayBar = document.getElementById('overlayBar');

  // ---- State
  let h5file = null;
  let demos = [];         // all demo names from file
  let include = new Set();// demos included for export
  let removed = new Set();// demos removed in session (UI only)
  let currentDemo = null;
  let sourceFilename = null;

  const state = {
    imageSrc: 'obs',         // 'obs' or 'next_obs'
    availableCams: [],       // obs keys ending with _image
    selectedCams: [],        // <=8
    camDS: {},               // name -> Dataset (from obs or next_obs)
    // time-series datasets (from obs/*)
    g_qpos: null,
    g_qvel: null,
    g_qtorque: null,
    g_tcp_pose: null,
    m_qpos: null,
    m_qvel: null,
    m_qtorque: null,
    eef_pose: null,
    other_goal: null,
    other_cube: null,
    actions: null,
    T: 0, H: 224, W: 224,
    t: 0,
    _eefX: [], _eefY: [], _eefZ: []
  };

  const playback = { running:false, speed:1.0, dt:0.01, raf:null, last:0, acc:0 };

  // ---- Helpers
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  function sec(n){ return (Math.round(n*100)/100).toFixed(2) + "s"; }
  function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }
  function range(n){ return Array.from({length:n}, (_,i)=>i); }
  function verticalLine(x, color="#0066ff"){ return [{ type:"line", x0:x, x1:x, y0:0, y1:1, xref:"x", yref:"paper", line:{color, width:2, dash:"dot"} }]; }
  function extent(a){ let lo=Infinity, hi=-Infinity; for(const v of a){ if(v<lo) lo=v; if(v>hi) hi=v; } return [lo,hi]; }
  const nextTick = ()=> new Promise(r=>setTimeout(r,0));

  // camera drawing (single frame)
  function drawRGBToCanvas(canvas, flat, W, H){
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    const rgba = new Uint8ClampedArray(W*H*4);
    for(let i=0, j=0; i<W*H; i++){
      rgba[j++] = flat[i*3+0];
      rgba[j++] = flat[i*3+1];
      rgba[j++] = flat[i*3+2];
      rgba[j++] = 255;
    }
    const img = new ImageData(rgba, W, H);
    const tmp = document.createElement('canvas');
    tmp.width = W; tmp.height = H;
    tmp.getContext('2d').putImageData(img, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(tmp, 0, 0, rect.width, rect.height);
  }

  // ---- Theme toggle
  function setTheme(next){
    body.setAttribute('data-theme', next);
    themeToggle.textContent = (next === 'dark') ? 'üåô' : '‚òÄÔ∏è';
    const tpl = (next === 'dark') ? 'plotly_dark' : 'plotly_white';
    const common = { template: tpl, paper_bgcolor: 'transparent', plot_bgcolor: 'transparent' };
    Plotly.relayout(gripperPlotEl, common);
    Plotly.relayout(manipPlotEl,   common);
    Plotly.relayout(eefPlotEl,     common);
  }
  themeToggle.addEventListener('click', ()=>{
    const curr = body.getAttribute('data-theme') || 'dark';
    setTheme(curr === 'dark' ? 'light' : 'dark');
  });

  // ---- File loading
  fileInput.addEventListener('change', async (e)=>{
    await uploader(e);
    sourceFilename = UPLOADED_FILES.at(-1);
    h5file?.close?.();
    h5file = new h5wasm.File(sourceFilename, "r");
    fileInfo.textContent = `Loaded: ${sourceFilename}`;
    initFile();
  });

  // Download original (snapshot)
  downloadOrigBtn.addEventListener('click', ()=>{
    if(!h5file) return;
    download(h5file); // downloads the in-memory file as-is (name comes from h5file.filename)
  });

  // ---- Read structure
  function listDemos(){
    const dk = h5file.get('data').keys();
    // keep demo_* only
    return dk.filter(k=>k.startsWith('demo_') && !removed.has(k));
  }

  function buildDemoChip(name){
    const div = document.createElement('div'); div.className = 'chip';
    // left: [‚úì] demo_00000
    const left = document.createElement('div'); left.className = 'left';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = include.has(name);
    const label = document.createElement('span'); label.textContent = name; label.style.fontWeight=800;
    left.appendChild(cb); left.appendChild(label);
    // right: üóë
    const rm = document.createElement('span'); rm.className='remove'; rm.textContent='üóë';
    // click => select demo (view)
    left.addEventListener('click', (ev)=>{
      if(ev.target === cb) return;
      selectDemo(name);
    });
    // include toggle
    cb.addEventListener('change', ()=>{
      if(cb.checked) include.add(name); else include.delete(name);
    });
    // remove this demo from session (not destructive)
    rm.addEventListener('click', ()=>{
      removed.add(name); include.delete(name);
      initFile(); // rebuild list; if viewing this demo, switch to next available
    });
    div.appendChild(left); div.appendChild(rm);
    return div;
  }

  function initFile(){
    clear(demoChips);
    demos = listDemos();
    if(include.size === 0) demos.forEach(d=>include.add(d)); // include all by default
    demos.forEach((d,i)=>{
      const chip = buildDemoChip(d);
      demoChips.appendChild(chip);
    });

    // show env_args if present
    let env = '‚Äî';
    try{
      const envArgs = h5file.get('data').attrs['env_args']?.value;
      if(envArgs) {
        const meta = (typeof envArgs === 'string') ? JSON.parse(envArgs) : envArgs;
        env = (meta.env_name || meta.env || '‚Äî');
      }
    }catch(_){}
    envTag.textContent = `env: ${env}`;

    if(demos.length) selectDemo(demos[0]);
  }

  // discover cameras under obs
  function discoverCameras(demo){
    const obs = h5file.get(`data/${demo}/obs`);
    const keys = obs.keys();
    // any *_image keys are cameras
    const cams = keys.filter(k => k.endsWith('_image'));
    // prefer the classic four by default if present
    const preferred = ["front_image","left_side_image","overhead_image","right_side_image"];
    const sel = [];
    preferred.forEach(p => { if(cams.includes(p)) sel.push(p); });
    // fill up to 4 defaults; cap to 8
    const remaining = cams.filter(k => !sel.includes(k)).slice(0, Math.max(0, 4 - sel.length));
    const selected = [...sel, ...remaining].slice(0,8);
    return { cams, selected };
  }

  async function selectDemo(demo){
    currentDemo = demo;
    demoName.textContent = demo;

    // build camera list from obs (default source)
    state.imageSrc = imgSrcSel.value || 'obs';
    const { cams, selected } = discoverCameras(demo);
    state.availableCams = cams.slice(0, 8);
    state.selectedCams = selected;
    state.camDS = {};

    // build checklist UI
    clear(camChecklist);
    state.availableCams.forEach((name, i)=>{
      const id = `cam_${i}`;
      const row = document.createElement('label');
      row.innerHTML = `<input type="checkbox" id="${id}" ${selected.includes(name) ? 'checked' : ''}> <span>${name}</span>`;
      camChecklist.appendChild(row);
      document.getElementById(id).addEventListener('change', rebuildCams);
    });
    selectAllCams.onclick = ()=>{ [...camChecklist.querySelectorAll('input')].forEach(cb=>cb.checked=true); rebuildCams(); };
    clearCams.onclick = ()=>{ [...camChecklist.querySelectorAll('input')].forEach(cb=>cb.checked=false); rebuildCams(); };

    // timeseries (from obs)
    const base = `data/${demo}/obs`;
    const safeGet = (k)=>{ try{ return h5file.get(`${base}/${k}`); } catch{ return null; } };
    state.g_qpos    = safeGet('gripper_qpos');
    state.g_qvel    = safeGet('gripper_qvel');
    state.g_qtorque = safeGet('gripper_qtorque');
    state.g_tcp_pose= safeGet('gripper_tcp_pose');

    state.m_qpos    = safeGet('manipulator_qpos');
    state.m_qvel    = safeGet('manipulator_qvel');
    state.m_qtorque = safeGet('manipulator_qtorque');

    state.eef_pose  = safeGet('manipulator_eef_pose');
    state.other_goal= safeGet('other_goal_pos');
    state.other_cube= safeGet('other_cube_pos');

    // optional actions
    try{ state.actions = h5file.get(`data/${demo}/actions`); } catch{ state.actions = null; }

    // build advanced signals checklist
    buildAdvancedSignals();

    // compute T/H/W (min across selected cameras and required signals)
    rebuildCams(); // sets camDS & T / H / W
    await buildPlots();
    await renderFrame(0, true);

    // KPIs
    const dt = Number(dtInput.value) || 0.01;
    kpiTime.textContent = sec(state.T * dt);
  }

  // advanced signals list (overlays on plots)
  function buildAdvancedSignals(){
    const adv = document.getElementById('advSignals');
    clear(adv);
    const options = [
      { id:'gvel', label:'gripper_qvel', present: !!state.g_qvel, group:'gripper' },
      { id:'gtau', label:'gripper_qtorque', present: !!state.g_qtorque, group:'gripper' },
      { id:'gtcp', label:'gripper_tcp_pose', present: !!state.g_tcp_pose, group:'gripper' },
      { id:'mvel', label:'manipulator_qvel', present: !!state.m_qvel, group:'manip' },
      { id:'mtau', label:'manipulator_qtorque', present: !!state.m_qtorque, group:'manip' },
      { id:'act',  label:'actions', present: !!state.actions, group:'manip' },
      { id:'goal', label:'other_goal_pos (3D markers)', present: !!state.other_goal, group:'eef' },
      { id:'cube', label:'other_cube_pos (3D markers)', present: !!state.other_cube, group:'eef' },
    ];
    options.forEach(opt=>{
      if(!opt.present) return;
      const lab = document.createElement('label');
      lab.innerHTML = `<input type="checkbox" data-group="${opt.group}" data-id="${opt.id}"> <span>${opt.label}</span>`;
      adv.appendChild(lab);
    });
    adv.addEventListener('change', ()=> buildPlots()); // rebuild plots when toggled
  }

  // rebuild camera DS and cards
  function rebuildCams(){
    // selected
    state.selectedCams = [];
    for(const row of [...camChecklist.querySelectorAll('label')]){
      const cb = row.querySelector('input');
      const name = row.querySelector('span').textContent;
      if(cb.checked){ state.selectedCams.push(name); }
    }
    // camera datasets from selected imageSrc
    state.camDS = {};
    const base = `data/${currentDemo}/${state.imageSrc}`;
    for(const name of state.selectedCams){
      try{ state.camDS[name] = h5file.get(`${base}/${name}`); } catch(_){}
    }
    // camera cards
    clear(camsGrid);
    state.selectedCams.forEach(name=>{
      const card = document.createElement('div'); card.className = 'cam-card';
      const tag = document.createElement('div'); tag.className = 'cam-label'; tag.textContent = name;
      const canvas = document.createElement('canvas'); canvas.id = `canvas_${name}`;
      card.appendChild(tag); card.appendChild(canvas); camsGrid.appendChild(card);
    });

    // compute T/H/W (min across cams + eef + gripper/manip pos)
    let T = Infinity, H = 224, W = 224;
    if(state.g_qpos)    T = Math.min(T, state.g_qpos.shape[0]);
    if(state.m_qpos)    T = Math.min(T, state.m_qpos.shape[0]);
    if(state.eef_pose)  T = Math.min(T, state.eef_pose.shape[0]);
    for(const name of state.selectedCams){
      const ds = state.camDS[name]; if(!ds) continue;
      T = Math.min(T, ds.shape[0]); H = ds.shape[1]; W = ds.shape[2];
    }
    if(!isFinite(T)) T = 0;
    state.T = T; state.H = H; state.W = W;
    slider.max = String(Math.max(0, T-1)); slider.value = "0";
    kpiFrames.textContent = String(T); kpiTMax.textContent = String(Math.max(0, T-1));
    state.t = 0;
  }

  imgSrcSel.addEventListener('change', ()=>{
    state.imageSrc = imgSrcSel.value;
    rebuildCams();
    renderFrame(0, true);
  });

  // ---- Build plots (compact) with overlays
  async function buildPlots(){
    const T = state.T, tvec = range(T);
    const tpl = (body.getAttribute('data-theme')==='dark') ? 'plotly_dark' : 'plotly_white';
    const common = { template: tpl, margin:{l:40,r:8,t:24,b:28}, paper_bgcolor:'transparent', plot_bgcolor:'transparent' };
    const advOn = (id)=> !!document.querySelector(`#advSignals input[data-id="${id}"]`)?.checked;

    // Gripper (base: qpos)
    const gpTraces = [];
    if(state.g_qpos){
      const D = state.g_qpos.shape[1], flat = state.g_qpos.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        gpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`q${j}`, line:{width:1.6} });
      }
    }
    if(advOn('gvel') && state.g_qvel){
      const D = state.g_qvel.shape[1], flat = state.g_qvel.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        gpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`vel${j}`, line:{width:1, dash:'dot'} });
      }
    }
    if(advOn('gtau') && state.g_qtorque){
      const D = state.g_qtorque.shape[1], flat = state.g_qtorque.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        gpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`tau${j}`, line:{width:1, dash:'dash'} });
      }
    }
    if(advOn('gtcp') && state.g_tcp_pose){
      const D = state.g_tcp_pose.shape[1], flat = state.g_tcp_pose.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        gpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`tcp${j}`, line:{width:1, dash:'dot'} });
      }
    }
    await Plotly.newPlot(gripperPlotEl, gpTraces, {
      ...common, showlegend:true, legend:{orientation:'h', yanchor:'bottom', y:1.02, x:0},
      xaxis:{ title:'timestep', rangemode:'nonnegative', showgrid:true },
      yaxis:{ title:'gripper', showgrid:true },
      shapes: verticalLine(0)
    }, {displayModeBar:false, responsive:true});

    // Manip (base: qpos)
    const mpTraces = [];
    if(state.m_qpos){
      const D = state.m_qpos.shape[1], flat = state.m_qpos.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        mpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`q${j}`, line:{width:1.6} });
      }
    }
    if(advOn('mvel') && state.m_qvel){
      const D = state.m_qvel.shape[1], flat = state.m_qvel.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        mpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`vel${j}`, line:{width:1, dash:'dot'} });
      }
    }
    if(advOn('mtau') && state.m_qtorque){
      const D = state.m_qtorque.shape[1], flat = state.m_qtorque.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        mpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`tau${j}`, line:{width:1, dash:'dash'} });
      }
    }
    if(advOn('act') && state.actions){
      const D = state.actions.shape[1], flat = state.actions.value;
      for(let j=0;j<D;j++){
        const y = new Array(T); for(let t=0;t<T;t++) y[t] = flat[t*D + j];
        mpTraces.push({ x:tvec, y, type:'scatter', mode:'lines', name:`a${j}`, line:{width:1, dash:'dot'} });
      }
    }
    await Plotly.newPlot(manipPlotEl, mpTraces, {
      ...common, showlegend:true, legend:{orientation:'h', yanchor:'bottom', y:1.02, x:0},
      xaxis:{ title:'timestep', rangemode:'nonnegative', showgrid:true },
      yaxis:{ title:'manipulator', showgrid:true },
      shapes: verticalLine(0)
    }, {displayModeBar:false, responsive:true});

    // EEF 3D
    const x=[], y=[], z=[];
    if(state.eef_pose){
      const flat = state.eef_pose.value;
      for(let t=0;t<T;t++){ x.push(flat[t*6+0]); y.push(flat[t*6+1]); z.push(flat[t*6+2]); }
    }
    const traces = [
      { type:'scatter3d', mode:'lines', x, y, z, line:{width:2, color:'rgba(0,102,255,0.25)'}, name:'full' },
      { type:'scatter3d', mode:'lines', x:[x[0]], y:[y[0]], z:[z[0]], line:{width:4, color:'rgba(0,102,255,1.0)'}, name:'played' },
      { type:'scatter3d', mode:'markers', x:[x[0]], y:[y[0]], z:[z[0]], marker:{size:3}, name:'current' }
    ];
    // optional markers
    if(document.querySelector('#advSignals input[data-id="goal"]')?.checked && state.other_goal){
      const g = state.other_goal.value;
      const gx=[], gy=[], gz=[]; for(let t=0;t<T;t++){ gx.push(g[t*3+0]); gy.push(g[t*3+1]); gz.push(g[t*3+2]); }
      traces.push({ type:'scatter3d', mode:'markers', x: gx, y: gy, z: gz, marker:{size:2}, name:'goal' });
    }
    if(document.querySelector('#advSignals input[data-id="cube"]')?.checked && state.other_cube){
      const c = state.other_cube.value;
      const cx=[], cy=[], cz=[]; for(let t=0;t<T;t++){ cx.push(c[t*3+0]); cy.push(c[t*3+1]); cz.push(c[t*3+2]); }
      traces.push({ type:'scatter3d', mode:'markers', x: cx, y: cy, z: cz, marker:{size:2}, name:'cube' });
    }
    const xr = extent(x), yr = extent(y), zr = extent(z);
    const pad = (a,b)=> (b-a)*0.05 || 0.05;
    await Plotly.newPlot(eefPlotEl, traces, {
      ...common, margin:{l:0,r:0,t:26,b:0}, showlegend:false,
      scene:{
        xaxis:{ title:'X (m)', range:[xr[0]-pad(xr[0],xr[1]), xr[1]+pad(xr[0],xr[1])] },
        yaxis:{ title:'Y (m)', range:[yr[0]-pad(yr[0],yr[1]), yr[1]+pad(yr[0],yr[1])] },
        zaxis:{ title:'Z (m)', range:[zr[0]-pad(zr[0],zr[1]), zr[1]+pad(zr[0],zr[1])] },
        aspectmode:'cube',
        bgcolor:'rgba(0,0,0,0)'
      }
    }, {displayModeBar:false, responsive:true});

    state._eefX = x; state._eefY = y; state._eefZ = z;
  }

  // ---- Frame render
  async function renderFrame(t, force=false){
    t = clamp(t, 0, Math.max(0, state.T - 1));
    if(!force && t === state.t) return;
    state.t = t;
    slider.value = String(t); kpiT.textContent = String(t);

    // Cameras
    for(const name of state.selectedCams){
      const ds = state.camDS[name]; if(!ds) continue;
      const W = state.W, H = state.H;
      const flat = ds.slice([[t,t+1],[0,H],[0,W],[0,3]]);
      const canvas = document.getElementById(`canvas_${name}`);
      if(canvas) drawRGBToCanvas(canvas, flat, W, H);
    }

    // cursor on plots
    Plotly.relayout(gripperPlotEl, { shapes: verticalLine(t) });
    Plotly.relayout(manipPlotEl,   { shapes: verticalLine(t) });

    // EEF path
    if(state._eefX.length){
      const px = state._eefX.slice(0,t+1), py = state._eefY.slice(0,t+1), pz = state._eefZ.slice(0,t+1);
      Plotly.restyle(eefPlotEl, { x:[px], y:[py], z:[pz] }, [1]); // played
      Plotly.restyle(eefPlotEl, { x:[[state._eefX[t]]], y:[[state._eefY[t]]], z:[[state._eefZ[t]]] }, [2]); // current dot
    }
  }

  // ---- Playback
  function updateTiming(){ playback.dt = Math.max(0.001, Number(dtInput.value) || 0.01); playback.speed = Number(speedSel.value) || 1.0; }
  dtInput.addEventListener('change', ()=>{ updateTiming(); kpiTime.textContent = sec(state.T * playback.dt); });
  speedSel.addEventListener('change', ()=> updateTiming());
  function start(){
    if(playback.running) return;
    updateTiming(); playback.running = true; playBtn.textContent = '‚è∏ Pause';
    playback.last = performance.now(); playback.acc = 0;
    const period = ()=> 1000 * playback.dt / playback.speed;
    function tick(now){
      if(!playback.running) return;
      const elapsed = now - playback.last; playback.last = now; playback.acc += elapsed;
      const per = period();
      while(playback.acc >= per){ playback.acc -= per; const next = (state.t + 1) % Math.max(1, state.T); renderFrame(next); }
      playback.raf = requestAnimationFrame(tick);
    }
    playback.raf = requestAnimationFrame(tick);
  }
  function stop(){ if(!playback.running) return; playback.running = false; playBtn.textContent = '‚ñ∂ Play'; if(playback.raf) cancelAnimationFrame(playback.raf); playback.raf = null; }
  playBtn.addEventListener('click', ()=> playback.running ? stop() : start());
  slider.addEventListener('input', ()=> renderFrame(Number(slider.value), true));
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); playback.running ? stop() : start(); } if(e.code==='ArrowRight'){ stop(); renderFrame(state.t+1, true); } if(e.code==='ArrowLeft'){ stop(); renderFrame(state.t-1, true); } });

  // on resize, keep Plotly fitting containers
  window.addEventListener('resize', ()=>{ Plotly.Plots.resize(gripperPlotEl); Plotly.Plots.resize(manipPlotEl); Plotly.Plots.resize(eefPlotEl); });

  // ---- Export: build a pruned HDF5 in memory and download
  function showOverlay(msg, p){ overlay.style.display='flex'; overlayMsg.textContent = msg; overlayBar.style.width = (p||0)+'%'; }
  function hideOverlay(){ overlay.style.display='none'; }

  function getIncludedDemos(){ return demos.filter(d => include.has(d) && !removed.has(d)); }

  downloadPrunedBtn.addEventListener('click', async ()=>{
    if(!h5file) return;
    const keep = getIncludedDemos();
    if(keep.length===0){ alert('No demos selected. Use the ‚úì to include some demos first.'); return; }

    const baseName = (sourceFilename || 'dataset.hdf5').split('/').pop();
    const outName = `pruned_${baseName}`;
    showOverlay('Creating pruned HDF5‚Ä¶', 0);

    // Create output file & /data group
    const out = new h5wasm.File(outName, 'w');
    const outData = out.create_group('data');

    // Copy env_args (if present) and write total later
    const inData = h5file.get('data');
    try{
      const envArgs = inData.attrs['env_args']?.value;
      if(envArgs !== undefined) outData.create_attribute('env_args', envArgs);
    }catch(_){}

    // Recursively copy a group's datasets (flat copy; no hard links)
    async function copyGroup(inGroupPath, outGroup){
      const src = h5file.get(inGroupPath);
      for(const key of src.keys()){
        const path = `${inGroupPath}/${key}`;
        const obj = h5file.get(path);
        if(obj.keys){ // group
          const g = outGroup.create_group(key);
          // copy attributes
          try{
            const attrs = obj.attrs || {};
            for(const k of Object.keys(attrs)){ g.create_attribute(k, attrs[k].value); }
          }catch(_){}
          await copyGroup(path, g);
        } else {      // dataset
          const data = obj.value; // TypedArray / raw bytes
          const args = { name:key, data, shape: obj.shape, dtype: obj.dtype };
          // preserve gzip if present
          try{
            if((obj.filters||[]).some(f=>f.name==='deflate')){ args.compression = 'gzip'; args.compression_opts=[4]; }
          }catch(_){}
          outGroup.create_dataset(args);
          await nextTick();
        }
      }
    }

    // Copy each kept demo fully
    let total = 0, done=0, totalWork = keep.length;
    for(const d of keep){
      showOverlay(`Copying ${d}‚Ä¶`, Math.round(100 * (done / Math.max(1,totalWork))));
      const srcDemo = `data/${d}`;
      const gIn = h5file.get(srcDemo);
      // read num_samples attr to accumulate total
      try{ total += (gIn.attrs['num_samples']?.value || 0); }catch(_){}
      const gOut = outData.create_group(d);
      // copy attributes: num_samples, success, etc.
      try{
        const attrs = gIn.attrs || {};
        for(const k of Object.keys(attrs)){ gOut.create_attribute(k, attrs[k].value); }
      }catch(_){}
      // copy children: actions, dones, rewards, states, obs, next_obs
      await copyGroup(srcDemo, outData); // puts group at /data/<demo>/...
      done++;
      await nextTick();
    }
    // Update /data/total
    outData.create_attribute('total', Number(total));

    // (Optional) if /data/mask exists, filter lists to kept demos
    try{
      const mask = inData.get('mask');
      if(mask && mask.keys){
        const mOut = outData.create_group('mask');
        for(const k of mask.keys()){
          const ds = inData.get(`mask/${k}`);
          const arr = Array.from(ds.value).map(String).filter(name => keep.includes(name));
          mOut.create_dataset({ name:k, data: arr, dtype:'|S' });
        }
      }
    }catch(_){}

    hideOverlay();
    download(out); // downloads "pruned_<original>.hdf5"
    out.close();
  });

  // Initialize defaults
  setTheme('dark');
</script>
</body>
</html>
